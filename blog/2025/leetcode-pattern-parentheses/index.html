<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>Parenthesis problems are a staple of coding interviews and algorithm practice. They test your understanding of stacks, recursion, and string manipulation. In this post, I’ll walk you through some classic and challenging LeetCode parenthesis questions, from easy to hard, with sample Python solutions.</p> <h3>1. Valid Parentheses (Leetcode 20, Easy)</h3> <p>Problem:<br>Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:</p> <ul> <li>Open brackets are closed by the same type of brackets.</li> <li>Open brackets are closed in the correct order.</li> </ul> <p>Example:</p> <ul> <li>Input: s = "({[]})"</li> <li>Output: True</li> </ul> <p>Python Solution:</p> <pre>class Solution:<br>    def isValid(self, s: str) -&gt; bool:<br>        bracket_map = {')':'(',']':'[','}':'{'}<br>        st = []<br>        for c in s:<br>            if c not in bracket_map:<br>                st.append(c)<br>            else:<br>                if not st or st[-1] != bracket_map[c]:<br>                    return False<br>                st.pop()<br>        return not st</pre> <p>Time Complexity: O(n)<br>Space Complexity: O(n) (stack)</p> <p>Edge Cases:</p> <ol> <li>Empty string: "" → Valid.</li> <li>All opening brackets: "(((" → Invalid.</li> <li>Mixed types: "([)]" → Invalid.</li> </ol> <h3>2. Valid Parenthesis String (Leetcode 678, Medium)</h3> <p>Problem:<br>Given a string containing '(', ')', and '*', where '*' can be treated as '(', ')', or an empty string, determine if the string is valid.</p> <p>Example:</p> <ul> <li>Input: s = "(*))"</li> <li>Output: True</li> </ul> <p>Python Solution:</p> <pre>class Solution:<br>  def checkValidString(s: str) -&gt; bool:<br><br>    def isValid(opening, closing, s):<br>      open_cnt = 0<br>      for c in s:<br>          if c == opening or c == "*":<br>              open_cnt += 1<br>          elif c == closing:<br>              if open_cnt &lt;= 0:<br>                  return False<br>              open_cnt -= 1<br>      return True<br><br>    return isValid("(", ")", s) and isValid(")", "(", s[::-1])</pre> <p>Explanation:<br>We scan the string twice: left-to-right and right-to-left, treating '*' as both open and close. This greedy approach ensures every ')' can be matched.</p> <p>Time Complexity: O(n)<br>Space Complexity: O(1)</p> <p>Edge Cases:</p> <ol> <li>All stars: "***" → Valid.</li> <li>No stars: "(()" → Invalid.</li> <li>Stars as closers: "(*)" → Valid.</li> </ol> <h3>3. Generate Parentheses (Leetcode 22, Medium)</h3> <p>Problem:<br>Given n pairs of parentheses, generate all combinations of well-formed parentheses.</p> <p>Example:</p> <ul> <li>Input: n = 3</li> <li>Output: ["((()))","(()())","(())()","()(())","()()()"]</li> </ul> <p>Python Solution:</p> <pre>class Solution:<br>    def generateParenthesis(self, n: int) -&gt; List[str]:<br>      out = []<br>      def dfs(open, close, path):<br>        if close == n:<br>            if open == close:<br>                out.append("".join(path))<br>            return<br>        if open &lt; n:<br>            dfs(open + 1, close, path + ["("])<br>        if close &lt; open:<br>            dfs(open, close+1, path + [")"])<br>      <br>      dfs(0, 0, [])<br>      return out</pre> <p>Explanation:<br>This uses backtracking to generate all valid combinations, ensuring that at any time, the number of closing parentheses does not exceed the number of opening ones.</p> <p>Time Complexity: O(4^n / √n) (Catalan number)<br>Space Complexity: O(n) (recursion stack)</p> <p>Edge Cases:</p> <ol> <li>n = 1 → ["()"].</li> <li>n = 0 → [].</li> <li>n = 2 → ["(())", "()()"].</li> </ol> <h3>4. Minimum Remove to Make Valid Parentheses (Leetcode 1249, Medium)</h3> <p>Problem:<br>Given a string with parentheses and lowercase letters, remove the minimum number of brackets to make it valid.</p> <p>Example:</p> <ul> <li>Input: s = "a)b(c)d"</li> <li>Output: "ab(c)d"</li> </ul> <p>Python Solution:</p> <pre>class Solution:<br>    def minRemoveToMakeValid(self, s: str) -&gt; str:<br>        def getValid(s, openb):<br>            rs = []<br>            open_cnt = 0<br>            for c in s:<br>                if c == openb:<br>                    open_cnt += 1<br>                    rs.append(c)<br>                elif c == '(' or c == ')':<br>                    if open_cnt &gt; 0:<br>                        open_cnt -= 1<br>                        rs.append(c)<br>                else:<br>                    rs.append(c)<br>            return "".join(rs)<br>        <br>        s = getValid(s, "(")  # Remove invalid ')'<br>        s = getValid(s[::-1], ")")  # Remove invalid '(' (reverse string)<br>        return s[::-1]</pre> <p>Explanation:</p> <ol> <li>First pass removes invalid closing brackets.</li> <li>Reverse the string and remove invalid opening brackets.</li> </ol> <p>Time Complexity: O(n)<br>Space Complexity: O(n)</p> <p>Edge Cases:</p> <ol> <li>All invalid: "))((" → "".</li> <li>No brackets: "abc" → "abc".</li> <li>Nested brackets: "())()(((" → "()()".</li> </ol> <h3>5. Minimum Add to Make Parentheses Valid (Leetcode 921, Medium)</h3> <p>Problem:<br>Return the minimum number of additions needed to make parentheses valid.</p> <p>Example:</p> <ul> <li>Input: s = "())"</li> <li>Output: 1 (Add '(' at the start).</li> </ul> <p>Python Solution:</p> <pre>class Solution:<br>    def minAddToMakeValid(self, s: str) -&gt; int:<br>        ans, open = 0, 0<br>        for c in s:<br>            if c == "(":<br>                open += 1<br>            else:<br>                if open &gt; 0:<br>                    open -= 1<br>                else:<br>                    ans += 1<br>        return ans + open</pre> <p>Explanation:<br>Track unmatched opening and closing brackets.</p> <p>Time Complexity: O(n)<br>Space Complexity: O(1)</p> <p>Edge Cases:</p> <ol> <li>Empty string: "" → 0.</li> <li>All closing: "))" → 2.</li> <li>All opening: "(((" → 3.</li> </ol> <h3>6. Longest Valid Parentheses (Leetcode 32, Hard)</h3> <p>Problem:<br>Find the length of the longest valid parentheses substring.</p> <p>Example:</p> <ul> <li>Input: s = ")()())"</li> <li>Output: 4 (substring "()()").</li> </ul> <p>Python Solution:</p> <pre>class Solution:<br>    def longestValidParentheses(self, s: str) -&gt; int:<br>        def validLen(s, left_paren):<br>            ans = left = right = 0<br>            for c in s:<br>                if c == left_paren:<br>                    left += 1<br>                else:<br>                    right += 1<br>                if left == right:<br>                    ans = max(ans, left * 2)<br>                elif right &gt; left:<br>                    left = right = 0<br>            return ans<br>        <br>         return max(validLen(s, "("), validLen(s[::-1], ")"))</pre> <p>Explanation:<br>Two passes (left-to-right and right-to-left) to catch all valid substrings.</p> <p>Time Complexity: O(n)<br>Space Complexity: O(1)</p> <p>Edge Cases:</p> <ol> <li>All valid: "(()())" → 6.</li> <li>Alternating: ")()())" → 4.</li> <li>Single pair: "()" → 2.</li> </ol> <h3>7. Remove Invalid Parentheses (Leetcode 301, Hard)</h3> <p>Problem:<br>Remove the minimum number of brackets to make the string valid. Return all possible results.</p> <p>Example:</p> <ul> <li>Input: s = "()())()"</li> <li>Output: ["()()()", "(())()"]</li> </ul> <p>Python Solution:</p> <pre>class Solution:<br>    def removeInvalidParentheses(self, s: str) -&gt; List[str]:<br>        left, right = 0, 0<br>        for c in s:<br>            if c == "(":<br>                left += 1<br>            elif c == ")":<br>                if left &gt; 0:<br>                    left -= 1<br>                else:<br>                    right += 1                <br>        valid_len = len(s) - left - right<br><br>        ans = set()<br>        def rec(index, opn, valid_len, path):<br>            if valid_len == 0:<br>                if opn == 0: ans.add("".join(path))<br>                return<br>            <br>            if index == len(s):<br>                return<br>            <br>            char = s[index]<br>            if char == "(":<br>                # Include '('<br>                path.append(char)<br>                rec(index + 1, opn + 1, valid_len - 1, path)<br>                path.pop()<br>                # Skip '('<br>                rec(index + 1, opn, valid_len, path)<br>            elif char == ")":<br>                if opn &gt; 0:<br>                    # Include ')'<br>                    path.append(char)<br>                    rec(index + 1, opn - 1, valid_len - 1, path)<br>                    path.pop()<br>                # Skip ')'<br>                rec(index + 1, opn, valid_len, path)<br>            else:<br>                # Include non-parenthesis character<br>                path.append(char)<br>                rec(index + 1, opn, valid_len - 1, path)<br>                path.pop()<br>        rec(0, 0, valid_len, [])<br>        return list(ans)</pre> <p>Explanation:<br>Backtracking to generate all valid combinations by removing excess brackets.</p> <p>Time Complexity: O(2^n) (worst case)<br>Space Complexity: O(n) (recursion stack)</p> <p>Edge Cases:</p> <ol> <li>No valid solution: ")(" → [""].</li> <li>Multiple solutions: "()())()" → ["()()()", "(())()"].</li> <li>All characters: "a)b(c)d" → ["ab(c)d"].</li> </ol> <h3>Tips and Tricks for Interviews</h3> <ol> <li>Stack Usage: For validation and tracking nested structures.</li> <li>Counter Variables: Track open/close counts.</li> <li>Two-Pass Approach: For problems requiring bidirectional checks.</li> <li>Backtracking: Generate all valid combinations.</li> <li>Edge Cases: Always test empty strings, all valid/invalid brackets towards start and end of the input, and mixed characters.</li> </ol> <p>Happy Coding!<br><em>Follow me for more algorithm insights and Python solutions!</em></p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f0cbc8447b04" width="1" height="1" alt=""></p> </body></html>