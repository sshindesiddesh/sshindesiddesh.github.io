<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>A <strong>monotonic stack</strong> is a powerful data structure and algorithm pattern that maintains elements in either strictly increasing or decreasing order. It’s particularly useful for solving array-based problems that involve finding the next greater or smaller element, calculating spans, or identifying boundaries efficiently. Unlike brute-force approaches that might require O(n²) time complexity, monotonic stacks often solve these problems in just O(n) time, making them perfect for technical interviews.</p> <p>In this post, I’ll guide you through six classic LeetCode problems that leverage the monotonic stack pattern, from straightforward applications to more complex scenarios.</p> <h3>1. Daily Temperatures (LeetCode 739, Medium)</h3> <p><strong>Problem:</strong></p> <p>Given an array of integers temperatures representing daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] = 0.</p> <p><strong>Example:</strong></p> <ul> <li>Input: temperatures =[73][74][75][71][69][72][76][73]</li> <li>Output: [1][1][4][2][1][1]</li> <li>Explanation:</li> <li>Day 0 (73°): Wait 1 day for a warmer temperature (74°)</li> <li>Day 1 (74°): Wait 1 day for a warmer temperature (75°)</li> <li>Day 2 (75°): Wait 4 days for a warmer temperature (76°)</li> <li>Day 3 (71°): Wait 2 days for a warmer temperature (72°)</li> <li>Day 4 (69°): Wait 1 day for a warmer temperature (72°)</li> <li>Day 5 (72°): Wait 1 day for a warmer temperature (76°)</li> <li>Day 6 (76°): No future warmer temperature (0)</li> <li>Day 7 (73°): No future warmer temperature (0)</li> </ul> <p><strong>Python Solution:</strong></p> <pre>class Solution:<br>    def dailyTemperatures(self, nums: List[int]) -&gt; List[int]:<br>        stack = []<br>        ans = [0] * len(nums)<br>        for cur_day, cur_temp in enumerate(nums):<br>            while stack and cur_temp &gt; stack[-1][1]:<br>                past_day, past_temp = stack.pop()<br>                ans[past_day] = cur_day - past_day<br>            stack.append((cur_day, cur_temp))<br>        return ans</pre> <p><strong>Explanation:</strong></p> <p>This is a classic application of a monotonic decreasing stack. We store pairs of (day_index, temperature) in our stack. For each current temperature:</p> <ol> <li>While the stack is not empty and the current temperature is warmer than the temperature at the top of the stack, we pop the stack.</li> <li>For each popped entry, we calculate the waiting days by subtracting the past day from the current day.</li> <li>We push the current day and temperature onto the stack.</li> </ol> <p><strong>Time Complexity:</strong> O(n) — Each element is pushed and popped at most once.<br> <strong>Space Complexity:</strong> O(n) — In the worst case, the stack stores all temperatures.</p> <p><strong>Edge Cases:</strong></p> <ul> <li>All increasing temperatures: Each temperature waits exactly 1 day</li> <li>All decreasing temperatures: All answers are 0 except the last which is also 0</li> <li>Single temperature: The answer is</li> </ul> <h3>2. Next Greater Element II (LeetCode 503, Medium)</h3> <p><strong>Problem:</strong></p> <p>Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums), return the next greater number for every element in nums. The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.</p> <p><strong>Example:</strong></p> <ul> <li>Input: nums =[1][2][1]</li> <li>Output: [2, -1, 2]</li> <li>Explanation:</li> <li>The next greater element for 1 is 2</li> <li>The next greater element for 2 doesn’t exist (so output -1)</li> <li>The next greater element for the last 1 is 2 (circling back to the beginning)</li> </ul> <p><strong>Python Solution:</strong></p> <pre>class Solution:<br>    def nextGreaterElements(self, nums):<br>        n = len(nums)<br>        nums = nums + nums  # Duplicate array to handle circular nature<br>        out = [-1] * n<br>        stack = []<br>        for index, val in enumerate(nums):<br>            while stack and stack[-1][1] &lt; val:<br>                out[(stack[-1][0]) % n] = val<br>                stack.pop()<br>            stack.append((index, val))<br>        return out</pre> <p><strong>Explanation:</strong></p> <p>This problem extends the classic “next greater element” problem by adding the circular array constraint. The elegant approach here:</p> <ol> <li>Duplicate the array to simulate the circular nature (nums + nums)</li> <li>Use a monotonic decreasing stack to track indices and values</li> <li>When a greater element is found, update the result array while accounting for the circular nature using modulo operation</li> <li>Continue until all elements are processed</li> </ol> <p><strong>Time Complexity:</strong> O(n) — Each element is processed at most twice.<br> <strong>Space Complexity:</strong> O(n) — Stack size and duplicated array.</p> <p><strong>Edge Cases:</strong></p> <ul> <li>Single element array: Return [-1]</li> <li>All equal elements: All outputs are -1</li> <li>Strictly increasing array: All outputs except the last are the next element; the last is -1</li> </ul> <h3>3. Largest Rectangle in Histogram (LeetCode 84, Hard)</h3> <p><strong>Problem:</strong></p> <p>Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p> <p><strong>Example:</strong></p> <ul> <li>Input: heights =[2][1][5][6][2][3]</li> <li>Output: 10</li> <li>Explanation: The largest rectangle has an area of 10 units (height 5 with width 2, formed by the 5 and 6 height bars)</li> </ul> <p><strong>Python Solution:</strong></p> <pre>class Solution:<br>    def largestRectangleArea(self, heights: List[int]) -&gt; int:<br>        """<br>        Algorithm:<br>        - push -1 on the stack<br>        - keep pushing on the stack if the cur height is greater than one on the top of the stack<br>            - keep only indexes in the stack<br>        - while popping any height<br>            - the max rectangle with that height is <br>            - first height &lt; cur on the left and on the right.<br>            - i.e. cur - stack top - 1 * cur_height<br>        - add additional zero towards the end to make popping easy<br>        """<br>        heights.append(0)  # Add sentinel to ensure all bars are processed<br>        stack = [-1]  # Initialize with -1 to handle edge cases<br>        ans = 0<br>        <br>        for index in range(len(heights)):<br>            while stack[-1] != -1 and heights[stack[-1]] &gt; heights[index]:<br>                ans_index = stack.pop()<br>                left, right = stack[-1], index<br>                ans = max(ans, (right - left - 1) * heights[ans_index])<br>            stack.append(index)<br>        return ans</pre> <p><strong>Explanation:</strong></p> <p>This is a more complex application of monotonic stacks. The key insight:</p> <ol> <li>For each bar, the maximum rectangle with that bar as the height extends to the nearest shorter bar on both sides</li> <li>We use a monotonic increasing stack to track indices</li> <li>When we find a shorter bar, we pop the stack and calculate rectangles</li> <li>The sentinel value 0 at the end ensures all bars are processed</li> <li>The sentinel -1 at the beginning helps calculate widths correctly</li> </ol> <p><strong>Time Complexity:</strong> O(n) — Each bar is pushed and popped exactly once.<br> <strong>Space Complexity:</strong> O(n) — Stack size in worst case.</p> <p><strong>Edge Cases:</strong></p> <ul> <li>Single bar: Area is the height of that bar</li> <li>All bars same height: Area is height * number of bars</li> <li>Empty array: Return 0</li> </ul> <h3>4. Number of Visible People in a Queue (LeetCode 1944, Hard)</h3> <p><strong>Problem:</strong></p> <p>There are n people standing in a queue, numbered from 0 to n-1 in left to right order. You are given an array heights of distinct integers where heights[i] represents the height of the ith person. A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the ith person can see the jth person if i &lt; j and min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1]). Return an array answer where answer[i] is the number of people the ith person can see to their right in the queue.</p> <p><strong>Example:</strong></p> <ul> <li>Input: heights =[10][6][8][5][11][9]</li> <li>Output: [3][1][2][1][1]</li> <li>Explanation:</li> <li>Person 0 (height 10) can see persons 1, 2, and 4</li> <li>Person 1 (height 6) can see person 2</li> <li>Person 2 (height 8) can see persons 3 and 4</li> <li>Person 3 (height 5) can see person 4</li> <li>Person 4 (height 11) can see person 5</li> <li>Person 5 (height 9) can’t see anyone</li> </ul> <p><strong>Python Solution:</strong></p> <pre>class Solution:<br>    def canSeePersonsCount(self, heights: List[int]) -&gt; List[int]:<br>        stack = []<br>        ans = []<br>        n = len(heights)<br>        <br>        for x in range(n-1, -1, -1):<br>            ret = 0<br>            while stack and heights[x] &gt;= stack[-1]:<br>                stack.pop()<br>                ret += 1<br>            ans.append(ret + (1 if stack else 0))<br>            stack.append(heights[x])<br>        <br>        return ans[::-1]</pre> <p><strong>Explanation:</strong></p> <p>This solution uses a monotonic stack to track visible people, processing from right to left:</p> <ol> <li>For each person, we count how many people they can see</li> <li>We use a monotonic stack to maintain heights of people to the right</li> <li>We pop people shorter than current person (they’re visible) and count them</li> <li>If the stack is not empty after popping, the tallest remaining person is also visible</li> <li>Finally, we reverse the answer since we processed from right to left</li> </ol> <p><strong>Time Complexity:</strong> O(n) — Each height is pushed and popped at most once.<br> <strong>Space Complexity:</strong> O(n) — Stack size in worst case.</p> <p><strong>Edge Cases:</strong></p> <ul> <li>Single person: Return</li> <li>Strictly increasing heights: Each person sees only the next person</li> <li>Strictly decreasing heights: Each person sees everyone to their right</li> </ul> <h3>5. Verify Preorder Sequence in Binary Search Tree (LeetCode 255, Medium)</h3> <p><strong>Problem:</strong></p> <p>Given an array of unique integers preorder, return true if it is the correct preorder traversal sequence of a binary search tree.</p> <p><strong>Example:</strong></p> <ul> <li>Input: preorder =[5][2][1][3][6]</li> <li>Output: true</li> <li>Explanation: This could be the preorder traversal of a BST with root 5, left subtree, and right subtree</li> </ul> <p><strong>Python Solution:</strong></p> <pre>class Solution:<br>    def verifyPreorder(self, preorder: List[int]) -&gt; bool:<br>        stack = []<br>        min_val = float("-inf")<br>        <br>        for val in preorder:<br>            while stack and stack[-1] &lt; val:<br>                min_val = max(min_val, stack.pop())<br>            <br>            if val &lt;= min_val:<br>                return False<br>                <br>            stack.append(val)<br>        return True</pre> <p><strong>Explanation:</strong></p> <p>This problem combines BST properties with monotonic stacks. The key insight:</p> <ol> <li>In a valid preorder traversal, once we start visiting a right subtree, all subsequent values must be greater than all ancestors of that right subtree</li> <li>We use a stack to simulate the traversal</li> <li>When we encounter a value greater than the stack top, we’re moving to a right subtree</li> <li>We keep track of a minimum value (min_val) that all future nodes must exceed</li> <li>If a value is less than or equal to this minimum, the preorder sequence is invalid</li> </ol> <p><strong>Time Complexity:</strong> O(n) — Each element is processed exactly once.<br> <strong>Space Complexity:</strong> O(n) — Stack size in worst case.</p> <p><strong>Edge Cases:</strong></p> <ul> <li>Single element: Always valid</li> <li>Sorted array (increasing): Valid preorder of a right-skewed BST</li> <li>Sorted array (decreasing): Valid preorder of a left-skewed BST</li> </ul> <h3>6. Remove K Digits (LeetCode 402, Medium)</h3> <p><strong>Problem:</strong></p> <p>Given string num representing a non-negative integer, and an integer k, return the smallest possible integer after removing k digits from num.</p> <p><strong>Example:</strong></p> <ul> <li>Input: num = "1432219", k = 3</li> <li>Output: "1219"</li> <li>Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</li> </ul> <p><strong>Python Solution:</strong></p> <pre>class Solution:<br>    def removeKdigits(self, num, k):<br>        st = []<br>            <br>        for n in num:<br>            while st and st[-1] &gt; n and k:<br>                st.pop()<br>                k -= 1<br>            if st or n != '0':<br>                st.append(n)<br>        <br>        if k:<br>            st = st[0:-k]<br>        return ''.join(st) or '0'</pre> <p><strong>Explanation:</strong></p> <p>This problem is a perfect application of a monotonic increasing stack:</p> <ol> <li>We want to maintain the smallest possible number, which means keeping digits in increasing order</li> <li>When we encounter a digit smaller than the top of our stack, we remove the top (if we still have removals left)</li> <li>This greedy approach ensures we’re always removing the largest possible digit</li> <li>We handle leading zeros by only adding a digit if the stack is non-empty or the digit is not ‘0’</li> <li>If we still have removals left after processing all digits, we remove from the end</li> <li>If the final result is empty, we return “0”</li> </ol> <p><strong>Time Complexity:</strong> O(n) — Each digit is processed at most twice.<br> <strong>Space Complexity:</strong> O(n) — Stack size in worst case.</p> <p><strong>Edge Cases:</strong></p> <ul> <li>Empty string: Return “0”</li> <li>k equals length of num: Return “0”</li> <li>num is already the smallest possible: Remove the last k digits</li> </ul> <h3>Tips and Tricks for Monotonic Stack Problems</h3> <p><strong>Pattern Recognition:</strong></p> <ul> <li>Look for problems about finding the next greater/smaller element.</li> <li>Problems involving ranges, spans, or heights often benefit from monotonic stacks.</li> <li>Questions about maintaining a “view” or visibility usually suggest this pattern.</li> </ul> <p><strong>Stack Type Selection:</strong></p> <ul> <li>Use a monotonic <strong>increasing</strong> stack when looking for next/previous <strong>smaller</strong> elements.</li> <li>Use a monotonic <strong>decreasing</strong> stack when looking for next/previous <strong>greater</strong> elements.</li> <li>Remember: “Increasing stack finds smaller elements, decreasing stack finds greater elements”.</li> </ul> <p><strong>Implementation Efficiency:</strong></p> <ul> <li>Store indices in the stack rather than values when you need position information.</li> <li>Use sentinels (like -1, 0, or infinity values) to handle edge cases elegantly.</li> <li>Consider processing the array in reverse for “previous” element problems.</li> </ul> <p><strong>Circular Array Handling:</strong></p> <ul> <li>For circular arrays, either duplicate the array or use modulo arithmetic.</li> <li>Use a second pass through the array or extend the array conceptually.</li> </ul> <p><strong>Greedy Decision Making:</strong></p> <ul> <li>Monotonic stacks inherently implement a greedy strategy.</li> <li>For optimization problems (like Remove K Digits), the stack maintains the optimal solution.</li> </ul> <p>Happy coding, and good luck with your next interview!</p> <p><em>Follow me for more algorithm insights and Python solutions!</em></p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=88f1fc3f4455" width="1" height="1" alt=""></p> </body></html>